#!/usr/bin/env zsh
#
# Copyright (C) 2016 Dyne.org Foundation
#
# Designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it
# and/or modify it under the terms of the GNU Public License
# as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later
# version.
#
# This source code is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  Please refer to the GNU Public License for more
# details.
#
# You should have received a copy of the GNU Public License
# along with this source code; if not, write to: Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
# 02139, USA.

# This standalone program runs every N seconds and gathers current
# information on network objects, updating it in redis


source $R/env

now=`date --utc +'%s'`

pendulum_ip_to_network() {
    fn pendulum_ip_to_network $*
    local _addr="$1"
    req=(_addr)
    ckreq || return $?
    print "${_addr[(ws:.:)1]}.${_addr[(ws:.:)2]}.${_addr[(ws:.:)3]}.0/24"
}


_pendulum_resolve_hostname() {
    fn pendulum_resolve_hostname $*
    [[ "$obj[ip4]" = "" ]] && return 1

    hh="`host $obj[ip4] | awk '
/NXDOMAIN/ { exit }
{ print $NF }'`"
    # hh[${#hh}]='\0'
    [[ "$hh" = "" ]] || {
        obj[hostname]=${hh%%.*}
    }
}

# DNS rotation if current dnscrypt server is unreachable
round_robin_dns() {
	fn round_robin_dns $*

    local _dnslog=1
	local _ttl=1

    [[ $DEBUG = 1 ]] && _dnslog=7

	# check currently used server, trigger rotation only if necessary
	local _dns
    _dns=$(print "GET dns-server-selected" | redis dynamic)
	# trim a nil response from redis as empty string
	# TODO: should it go into the redis wrapper?
	_dns=${_dns/\(nil\)/}
	[[ "$_dns" = "" ]] || {
		# test currently used dns
		${execmap[dnscrypt-proxy]} -L $R/share/dnscrypt-resolvers.csv \
								   -R ${_dns} -t $_ttl -m $_dnslog
		# return success if current dns works and rotation not
		# necessary
		[[ $? = 0 ]] && {
			func "rrdns: current dnscrypt server '$_dns' OK"
			return 0 }
	}

	warning "rrdns: current dnscrypt server is unreachable, rotating"

	# generate a random entry for dnscrypt-proxy test with a single
	# csv line TODO: choose specific servertype with no logs, dnssec
	# etc.
	ztmp
	local _dnsrand=$ztmpfile
	sed 1q $R/share/dnscrypt-resolvers.csv > $_dnsrand
    local _rndresolv
	_rndresolv="$(perl -wne '$a = $_ if rand $. < 1 ; END { print $a }' $R/share/dnscrypt-resolvers.csv)"
	print "$_rndresolv" >> $_dnsrand
    dnscrypt_name="${_rndresolv[(ws:,:)1]}"

	func "rrdns: testing $dnscrypt_name"

	(sleep $_ttl; rm -f $_dnsrand) &
	# run the dnscrypt-proxy in test mode with 10s timeout
	${execmap[dnscrypt-proxy]} -L $_dnsrand -R ${dnscrypt_name} \
							   -t $_ttl -m $_dnslog

    if [[ $? = 0 ]]; then
		func "rrdns: found working"
		func "${_rndresolv}"
		# Saving on redis the dnscrypt_name
		print "SET dns-server-selected ${dnscrypt_name}" | redis dynamic
		# stop the currently running daemon
		stop dnscrypt-proxy
		# let the watchdog start it
	else
		# unreachable, then recur with another random target
		dnscrypt-roundrobin
	fi
	return 0
}

################
# MAIN functions

fn "pendulum $*"

case "$1" in

	watchdog)
		wlid=`lock watchdog 60`
		[[ $wlid = 0 ]] && {
			func "watchdog already running"
			return 1 }

		# check that all registered pids are running
		# restart them if not running (and log that)
		pidmap=()
		watchdog_daemons

		unlock watchdog $wlid
		;;

	nextcmd)
		ncmd=`lock nextcmd 0`
		[[ "$ncmd" = "0" ]] && {
			func "nextcmd already locked"
			return 1 }

		exec_next_cmd

		unlock nextcmd $ncmd

		;;

	lease)
		# called by dhcp daemon when adding a new lease
		print "PUBLISH dhcp-lease-channel $*" | redis dynamic
		# shift 1
		return 0
		;;

	nmap)
		nlock=`lock nmap 30`
		# [[ $nlock = 0 ]] && {
		# 	func "nmap already running"
		# 	return 1 }

		nmapfile=$H/run/nmap_scan.xml
		ztmp
		processedfile=$ztmpfile

		ztmp
		varfile=$ztmpfile

		notice "Starting nmap scap of $dowse_net"
		act "results saved in $nmapfile"

 		nmap -n -F -sS -oX $nmapfile $dowse_net

		nmap-preprocess
		nmap-parse

		rm -f "${varfile}"
		rm -f "${processedfile}"

		#		unlock nmap $nlock
		;;

    netscan)
		slid=`lock netscan 30`
		[[ $? = 0 ]] || {
			func "netscan already running"
			return 1 }

        # parse everything in this map
        obj=()
		ip neigh | parse-ip-neigh.py

		unlock netscan $slid
        ;;

    rrdns)
		dlid=`lock rrdns 30`
		[[ $? = 0 ]] || {
			func "rrdns already running"
			return 1 }

		round_robin_dns

		unlock rrdns $dlid
		;;

	add-thing)
		iptables-set-thing $*
		;;

esac
