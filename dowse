#!/usr/bin/env zsh
#
# Copyright (C) 2012-2015 Dyne.org Foundation
#
# Dowse is designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it
# and/or modify it under the terms of the GNU Public License
# as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later
# version.
#
# This source code is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  Please refer to the GNU Public License for more
# details.
#
# You should have received a copy of the GNU Public License
# along with this source code; if not, write to: Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
# 02139, USA.


# {{{ GLOBALS

dowse_version=0.6
dowse_release_date="Feb/2015"

# Messaging function with pretty coloring
autoload colors
colors

typeset -aU vars
typeset -aU arrs
vars=()
arrs=()

# For gettext
TEXTDOMAIN=dowse

# path and debugging
vars+=(dowse_path dowse_loaded debug quiet script fun)
vars+=(last_notice last_act last_func)
vars+=(root)
arrs+=(mods)

# export DOWSE to env with path to the installation
# else start it from inside the dir with source dowse
dowse_path=${DOWSE_PATH:-`pwd`}
debug=${debug:-0}
quiet=${quiet:-0}

# uid/git
vars+=(dowse_uid dowse_gid)

# function requirement checks
arrs+=(req freq)

# globals filled by lease parser
arrs+=(host mac ip)

# globals used when loading modules
vars+=(dowse_mod_name dowse_mod_desc dowse_mod_version)
arrs+=(dowse_mod_type dowse_mod_ports dowse_mod_deps)
arrs+=(dowse_mod_authors dowse_mod_tags)

# consul's configuration map
typeset -A consul_conf
typeset -A consul_watch

zmodload zsh/system
zmodload zsh/mapfile
zmodload zsh/regex
zmodload zsh/sched
zmodload zsh/system
zmodload zsh/net/tcp

source $dowse_path/zlibs/messaging.sh
source $dowse_path/zlibs/processes.sh
source $dowse_path/zlibs/iptables.sh
source $dowse_path/zlibs/ebtables.sh
source $dowse_path/zlibs/confstore
source $dowse_path/zlibs/consul

source $dowse_path/daemons/dnsmasq
source $dowse_path/daemons/squid3
source $dowse_path/daemons/privoxy
source $dowse_path/daemons/polipo

# initialize globals only after sourcing
# since zlibs may contain more variable declarations
for v in $vars; do
    typeset -h $v
done
for a in $arrs; do
    typeset -a $a
done

fun=""
last_act=""
last_func=""
last_notice=""
consul_conf=()
consul_watch=()

dump dowse-internal-status() {
    act "Dowse status dump:"
    for v in $vars; do
        print "$v \t ${(P)v}"
    done
    for a in $arrs; do
        print "$a \t ${(P)a}"
    done
}


# debugging and require control
throw fn() {
    local msg="$1"
    command -v gettext 1>/dev/null 2>/dev/null \
        && msg="$(gettext -s "$1")"
    for i in $(seq 2 ${#}); do
        msg=${(S)msg//::$(($i - 1))*::/$*[$i]}
    done

    fun="$msg"
    func "$fun"
#    RPROMPT="$fun"
    req=()
    freq=()
}

zerr() { 
    error "error in: ${fun:-$last_notice}"

    [[ "$last_func" = "" ]] || warn "called in: $last_func"
    [[ "$last_act" = "" ]] || warn "called in: $last_act"
    [[ "$fun" = "" ]] || [[ "$fun" -regex-match "^Dowse" ]] || warn "called in: $last_notice"
    error "error reported, operation aborted."
    return 1
}
TRAPZERR() { zerr; return 1 }

ckreq reqck() {
    err=0
    for v in $req; do
        [[ "${(P)v}" = "" ]] && {
            warn "required setting is blank: $v"
            err=1
        }
    done

    [[ $err = 1 ]] && return $err

    for f in $freq; do
        # exists and has size greater than zero
        [[ -s $dowse_path/$f ]] || {
            warn "required file empty: $f"
            err=1
        }
    done
    return $err
}



if [[ $dowse_loaded = 1 ]]; then
    act "Dowse CLI reloaded ::1::" $dowse_version
    RPROMPT=Dowse
else
    notice "Dowse CLI ::1:: - local area network rabdomancy" $dowse_version
    dowse_loaded=1
    RPROMPT=Dowse
fi

cat <<EOF

 Copyright (C) 2012-2015 Dyne.org Foundation, License GNU GPL v3+
 This is free software: you are free to change and redistribute it
 For more informations see http://www.dyne.org/software/dowse

EOF

# }}}

# {{{ SYSTEM SETUP

sysctl-setup() {
    [[ -z $root ]] && {
        warn "no super user privileges: skipping sysctl settings"
        return 0
    }

    cat <<EOF | sysctl -p - >/dev/null
net.ipv4.tcp_syncookies = 1
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.core.rmem_max = 33554432
net.core.wmem_max = 33554432
net.ipv4.tcp_fin_timeout = 4
vm.min_free_kbytes = 65536
net.netfilter.nf_conntrack_tcp_timeout_established = 7200
net.netfilter.nf_conntrack_checksum = 0
net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 15
net.ipv4.tcp_keepalive_time = 60
net.ipv4.tcp_keepalive_intvl = 10
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.ip_local_port_range = 1025 65530
net.ipv4.tcp_timestamps = 0
EOF
}

dowse-check() {
    fn dowse-check
    act "checking requirements to run dowse..."
    # this is a check on binaries present in PATH
    # if not found, Dowse will abort.
    # for each found, Dowse will load zlibs/$.sh if present
#    for req in setuidgid dnsmasq iptables ebtables; do
#        require $req || return 1
#    done

    
    root=1
    [[ "$UID" = "0" ]] || unset root
    if [[ "$root" = "" ]]; then
        warn "no root privileges, limited functionality"
    else
        act "root privileges granted"
    fi

    dowse_uid=${dowse_uid:-`id -un`}
    dowse_gid=${dowse_gid:-`id -gn`}

    _verbose "Dowse command: ::1 commands::" "$*"
    _verbose "Caller: uid[::1 uid::], gid[::2 gid::], tty[::3 tty::]." \
        $dowse_uid $dowse_gid $TTY


    throw "$dowse_path/conf dowse_path_configuration"
    test -r $dowse_path/conf
    
    throw "$dowse_path/conf/settings dowse_path_configuration"
    test -r $dowse_path/conf/settings
    
    throw "$dowse_path/conf/network dowse_path_configuration"
    test -r $dowse_path/conf/network 

    act "daemons running as user and group $dowse_uid:$dowse_gid"
    mkdir -p $dowse_path/log
    mkdir -p $dowse_path/run
    [[ -z $root ]] || {
        # setup dirs
        chmod go-rwx $dowse_path/log
        chown -R $dowse_uid:$dowse_gid $dowse_path/log
        
        chmod go-rwx $dowse_path/run
        chown -R $dowse_uid:$dowse_gid $dowse_path/run
    }

    func "::1 dir:: directory writable by ::2 uid::" \
        run $dowse_uid
    touch $dowse_path/run/test
    rm -f $dowse_path/run/test

    func "::1 dir:: directory writable by ::2 uid::" \
        log $dowse_uid
    touch $dowse_path/log/test
    rm -f $dowse_path/log/test

    act "all requirements in place"

    return 0
}

# }}}


# {{{ DOWSE FUNCTIONS
dowse-setup() {
    notice "Setup dowse core configurations"
    freq=(conf/settings conf/network)
    ckreq

    dowse-check

    func "reading configuration in conf/settings"
    # zlibs/confstore
    conf-load


    [[ -z $root ]] || {

        # generate dnsmasq configuration
        rm -f $dowse_path/run/dnsmasq.conf
        dnsmasq-conf > $dowse_path/run/dnsmasq.conf

        # set permissions of setup files
        chown -R $dowse_uid:$dowse_gid $dowse_path/log
        chown -R $dowse_uid:$dowse_gid $dowse_path/run

    }

    chmod go-rwx $dowse_path/log
    chmod go-rwx $dowse_path/run

    act "setup completed in ::1 path::" $dowse_path
    return 0
}

# }}}

# {{{ MODULES

dowse-modules-setup() {
    fn dowse-module-setup
    req=(dowse_path)
    freq=(modules/enabled)
    ckreq

    mods=()
    enabled=`find -L $dowse_path/modules/enabled -maxdepth 1 -type d`

    # remove all service definitions for modules from consul
    consmods=`find $dowse_path/run/consul.d -maxdepth 1 -type f -name 'module-*.json'`
    for m in ${(f)consmods}; do
        rm -f $m
    done

    for i in ${(f)enabled}; do
        [[ -r $i/dowse ]] || continue
        
        mods+=($i)
        
        source $i/dowse
        notice "Setup module: ::1 name::" $dowse_mod_name
        act "$dowse_mod_desc"

        pushd $dowse_path
        module-setup
        popd

        func "announcing modules"
        .set modules/$dowse_mod_name "$dowse_mod_desc
type: $dowse_mod_type
ports: $dowse_mod_ports
depends: $dowse_mod_deps
authors: $dowse_mod_authors
version: $dowse_mod_version
"

        [[ ${#dowse_mod_ports} -gt 0 ]] && consul-add-service

    done
}

dowse-modules-start() {
    fn dowse-module-start
    req=(mods)
    freq=(modules/enabled)
    ckreq

    for i in $mods; do

        # execute the module-start()
        source $i/dowse
        notice "Setup module: ::1 name::" $dowse_mod_name
        act "$dowse_mod_desc"

        pushd $dowse_path
        module-start
        popd

        .set modules/$dowse_mod_name "
$dowse_mod_desc

type: $dowse_mod_type
ports: $dowse_mod_ports
depends: $dowse_mod_deps
authors: $dowse_mod_authors
version: $dowse_mod_version"

    done
    
    consul-reload

}

dowse-modules-stop() {
    fn dowse-module-stop

    enabled=`find -L $dowse_path/modules/enabled -maxdepth 1 -type d`
    for i in ${(f)enabled}; do

        [[ -r $i/dowse ]] || continue

        source $i/dowse
        
        pushd $dowse_path
        module-stop
        popd

    done
}

# }}}

# {{{ MAIN

dowse-start() {
    fn dowse-start
    req=(interface dowse netmask wan)
    freq=(run/dnsmasq.conf)
    ckreq

    function TRAPZERR() { }

    [[ -r $dowse_path/run/consul.pid ]] && {
        warn "Dowse is already running"
        return 0
    }
    notice "Starting Dowse"

    [[ -z $root ]] || {

        PGL=`pidof pgld`
        [[ "$PGL" = "" ]] || {
            act "PeerGuardian found running, will restart it accordingly"
            pglcmd stop }
        
        act "set up $interface interface"
        ifconfig $interface $dowse netmask $netmask up
        route add default gw $wan
        
        func "enable masquerading"
        modprobe nf_conntrack_ipv4
        sysctl net.netfilter.nf_conntrack_acct=1
        # strenghten and optimize a bit the system for networking
        sysctl-setup
        
        func "enable ip forwarding"
        print 1 >> /proc/sys/net/ipv4/ip_forward

        func "bugfix for routing table weirdness in Linux >3.1"
        # see https://lkml.org/lkml/2011/11/18/191
        # and http://www.spinics.net/lists/netdev/msg179687.html
        print 0 >>/proc/sys/net/ipv4/conf/$interface/accept_redirects

        [[ "$firewall" = "no" ]] || {
            ebtables-stop
            iptables-stop
        }        

        [[ "$firewall" = "yes" ]] && {
            ebtables-start
            iptables-start
        }
                
        # start the dnsmasq daemon
        dnsmasq-start run/dnsmasq.conf
        
        # if PeerGuardian was running, start it again
        [[ "$PGL" = "" ]] || { pglcmd start }

    }

    act "launching consul"
    consul-start


    dowse-modules-setup

    dowse-modules-start
    
}

dowse-stop() {
    fn "dowse-stop"
 
    dowse-modules-stop

    [[ -r $dowse_path/run/consul.pid ]] && consul-stop

    [[ -z $root ]] || {
        dnsmasq-stop
        iptables-stop
        ebtables-stop
    }

    act "Dowse is not running"

}

dowse-parse-leases() {
    awk '
BEGIN { c=0 }
{
  mac[c]=$2
  ip[c]=$3
  if($4=="*") host[c]="anonymous"; else host[c]=$4
  c++
}
END {
  printf "mac=("; for(i=0;i<c;i++) { printf "%s ", mac[i] }; printf ")\n"
  printf "ip=("; for(i=0;i<c;i++) { printf "%s ", ip[i] }; printf ")\n"
  printf "host=("; for(i=0;i<c;i++) { printf "%s ", host[i] }; printf ")\n"
}' $dowse_path/run/leases
}

dowse-status() {
    fn dowse-status
    freq=(run/leases)
    ckreq

    typeset -a mac ip host ping known
    notice "Reporting network status"
    eval `dowse-parse-leases`
    known=()
    ping=()

    function TRAPZERR() { }

    for i in {0..${#mac}}; do
        [[ $mac[$i] = "" ]] && { continue }

        known[$i]="unknown"
        grep "${mac[$i]}" $dowse_path/conf/network > /dev/null
        [[ $? = 0 ]] && known[$i]="known"

        ping[$i]="offline"
        nmap -sn -n -oG - $ip[$i] | grep -i 'status: up' > /dev/null
        [[ $? = 0 ]] && ping[$i]="online"

        if [[ "$known[$i]" == "known" ]]; then

            yes "$ping[$i]\t $mac[$i]\t $ip[$i]\t $host[$i]"
            .set things_known/$host[$i] "status: $ping[$i]
ip: $ip[$i]
mac: $mac[$i]"

        else

            no "$ping[$i]\t $mac[$i]\t $ip[$i]\t $host[$i]"
            .set things_unknown/$host[$i] "status: $ping[$i]
ip: $ip[$i]
mac: $mac[$i]"

        fi
    done
}

dowse-scan() {
    notice "Scanning unknown network objects"
    eval `dowse-parse-leases`

    for s in {0..${#mac}}; do
        [[ $mac[$s] == "" ]] && { continue }
        grep "${mac[$s]}" $dowse_path/conf/network > /dev/null
	    [[ $? == 1 ]] && { # unknown
	        act "Running scan on ::1 ip:: (::2 host::)" ${ip[$s]} ${host[$s]}
            func "$s: nmap -A -F -sT -Pn -T5 \"${ip[$s]}\""
            nmap -A -F -sT -Pn -T5 -n "${ip[$s]}"
	        print
        }
    done

}



# if args, call them
[[ "$*" = "" ]] || {
    TRAPZERR() { }
    $*
}

# be nice with the environment
# return $?

# }}}
