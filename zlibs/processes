#!/usr/bin/env zsh

# func "load paths and execmaps"
# maps+=(execmap execrules)
# execmap=()
# source $R/db/execmap.zkv
# execrules=()
# source $R/db/execrules.zkv

# high-level launcher using execmap and sup when necessary
launch() {
    fn launch $*
    local _cmd="$1"
    func "command: $_cmd"
    local _path=${execmap[$_cmd]}
    req=(_cmd _path)
    _freq=($_path)
    ckreq || return $?

    local _ret
    _rule=$execrules[$_cmd]
    case $_rule in
        user)
            shift 1
            func "user launch: $_path $*"
            $_path $*
            _ret=$?
            func "$_cmd (user) returns $_ret"
            return $_ret
            ;;
        root)
            shift 1
            func "root launch: $_path $*"
            $R/bin/sup $_path $*
            _ret=$?
            func "$_cmd (root) returns $_ret"
            return $_ret
            ;;
        *)
            error "unknown execrule for $_cmd to launch: $_rule"
            return 1
            ;;
    esac
}


# high-level daemon starter, synopsis:
#
# start daemon-name [ pidfile configfile ]
#
start() {
    fn start $*
    _daemon="$1"

    shift

    req=(_daemon)
    ckreq || return $?

	args="$*"

    conf=$H/run/$_daemon.conf

	# TODO: check if already running
    _pid=`getpid $_daemon`
    [[ "$_pid" = "" ]] || {
		warning "$_daemon already running (pid $_pid)"
        return 0
	}

    # if configuration is not defined, generate the default
    act "regenerating configuration for $_daemon"
    $_daemon-conf > $conf

    act "starting daemon: $_daemon $*"
    execpath=${execmap[$_daemon]}
    func "execpath: $execpath"
    [[ "$execpath" = "" ]] && {
		execpath=${execmap[${_daemon%-*}]}
		[[ "$execpath" = "" ]] && {
			error "$_daemon not found in execpath"
			return 1 }
	}

    if command -v $_daemon-exec > /dev/null; then
        # we preload jemalloc for better memory handling
		# need to detect the path for it
		case `arch` in
			x86_64)
				func "set LD_PRELOAD for jemalloc arch x84_64 ($_daemon)"
				LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.1 \
							  $_daemon-exec $args
					;;

			i686)
				func "set LD_PRELOAD for jemalloc arch i686 ($_daemon)"
				LD_PRELOAD=/usr/lib/i386-linux-gnu/libjemalloc.so.1 \
						  $_daemon-exec $args
					;;

			*) $_daemon-exec $args ;;

		esac

		func "$_daemon-exec $args"
        return $?
    else
        warning "daemon executable not found: $execpath"
        return 1
    fi
}

stop() {
    fn stop $*
    _daemon="$1"
    req=(_daemon)
    ckreq || return $?

    _pid=`getpid $_daemon`

    if [[ "$_pid" = "" ]]; then
		warning "$_daemon is not running"
        return 1
    else
        act "stopping $_daemon ($_pid)"
        if command -v $_daemon-kill > /dev/null; then
            $_daemon-kill
        else
            killpid $_pid
            waitpid $_pid || {
                error "$_daemon: could not stop pid $_pid"
                return 1 }
            [[ "$_daemon" = "redis-server" ]] || {
                print "DEL daemon-$_daemon-pid" | redis runtime
            }
        fi
    fi
    # TODO: kill -9
    return 0
}

savepid() {
    fn savepid $*

    local _daemon="$1"
    local _pid="$2"
    req=(_daemon)
    ckreq || return $?

	_lock=${_daemon}-savepid
	_key=`lock $_lock 20`
	_pidnum=""

	while islocked $_lock $_key; do
		sleep 1
		[[ -r $_pid ]] && {
			_pidnum=`cat $_pid`
			[[ "$_pidnum" != "" ]] && {
				func "$_pid contains $_pidnum"
				unlock $_lock $_key }
		}
	done

	[[ "$_pidnum" = "" ]] && {
		error "$_daemon did not write pid in $_pid"
		return 1
	}

    print "SET daemon-${_daemon}-pid \"$_pidnum\"" \
            | redis runtime > /dev/null
	# TODO: check redis result is OK?
	return 0
}

getpid() {
    fn getpid $*
    _daemon="$1"
    req=(_daemon)
    ckreq || return $?

    unset _pid

    print QUIT | redis runtime && {
        _pid=`print "GET daemon-${_daemon}-pid" | redis runtime` }

    # [[ "$_pid" = "" ]] && [[ -r $H/run/${_daemon}.pid ]] && {
    #     _pid=`cat $H/run/${_daemon}.pid` }

    if [[ "$_pid" = "" ]]; then
        func "$_daemon: pid not found"
        return 1
    else
        func "$_daemon pid found: $_pid"
    fi

    print $_pid
    return 0
}

killpid() {
    fn killpid $*
    _pid="$1"
    req=(_pid)
    ckreq || return $?


    ps -p $_pid > /dev/null || {
        warning "pid not running: $_pid"
        return 0 }

    func "killing $_daemon pid($_pid)"
    if [[ "$execrules[$_daemon]" = "root" ]]; then
        func "root daemon, using sup to kill"
        $R/bin/sup kill $_pid
    else
        kill $_pid
    fi

}

waitpid() {
    fn waitpid $*
    _pid="$1"
    _timeout=${2:-60}
    req=(_pid)
    ckreq || return $?

    local lastnewline=0
    for c in {1..$_timeout}; do
        # here check if pid its running
        if ps -p $_pid > /dev/null; then
            print -n . ; lastnewline=1
            sleep 1
        else
            break
        fi
        # todo: timeout with kill -9
    done
    # this because we care to look good on the console
    [[ $lastnewline = 1 ]] && print

    [[ $c = $_timeout ]] && {
        warning "operation timed out, pid($_pid) still running."
        return 1 }

    return 0
}

# prints a unique identifier of the lock used to unlock in case of success
# else returns nonzero in case of failure (lock timeout)
lock() {
	fn lock $*
	_lid="$1"
	timeout=${2:-10}
	req=(_lid)
	ckreq || return $?

	rand="$RANDOM$RANDOM"
	[[ `print "SET lock_$_lid $rand NX PX ${timeout}000" | redis runtime` = "OK" ]] && {
		print $rand
		func "succesful lock: $* (key $rand)"
		return 0 
	}
	func "failed lock: $*"
	return 1
}

unlock() {
	fn unlock $*
	_lid="$1"
	rand="$2"
	req=(_lid rand)
	ckreq || return $?

	res=`print "GET lock_$_lid" | redis runtime`
	[[ "$res" = "" ]] && {
		func "no lock to unlock: $*"
		return 0 }

    [[ "$rand" = "$res" ]] && {
		print "DEL lock_$_lid" | redis runtime
		func "succesful unlock: $* (key $res)"
		return 0
	}
	func "failed unlock: $* (key $res)"
	return 1
}

islocked() {
	fn islocked $*
	_lid="$1"
	rand="$2"
	req=(_lid rand)
	ckreq || return $?

	res=`print "GET lock_$_lid" | redis runtime`
    [[ "$rand" = "$res" ]] && {
		func "lock_${_lid} is still locked"
		return 0 }
	# else
	return 1
}
