#!/usr/bin/env zsh
#
# Copyright (C) 2016 Dyne.org Foundation
#
# Designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it
# and/or modify it under the terms of the GNU Public License
# as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later
# version.
#
# This source code is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  Please refer to the GNU Public License for more
# details.
#
# You should have received a copy of the GNU Public License
# along with this source code; if not, write to: Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
# 02139, USA.

# This standalone program runs every N seconds and gathers current
# information on network objects, updating it in redis

vars+=(now interval quit)
maps+=(obj)
destruens+=(exitloop)
quit=0
exitloop() { quit=1 }
source /usr/local/dowse/zshrc

# gather_network_info fills in global maps
net_devices=()
net.scan_devices
net_ip4_addr=()
net.scan_addresses

now=`date +'%s'`
interval=10 # seconds


pendulum_ip_to_network() {
    fn pendulum_ip_to_network $*
    local _addr="$1"
    req=(_addr)
    ckreq || return $?
    print "${_addr[(ws:.:)1]}.${_addr[(ws:.:)2]}.${_addr[(ws:.:)3]}.0/24"
}


_pendulum_resolve_hostname() {
    fn pendulum_resolve_hostname $*
    [[ "$obj[ip4]" = "" ]] && {
        obj[hostname]=""
        return 1
    }

    hh="`host $obj[ip4] | awk '
/NXDOMAIN/ { exit }
{ print $NF }'`"
    # hh[${#hh}]='\0'
    [[ "$hh" = "" ]] ||
        obj[hostname]=${hh%%.*}
    func "resolved: $obj[hostname]"
}

_pendulum_update_changes() {
    fn pendulum_update_changes $*
    macaddr="$obj[macaddr]"
    req=(macaddr)
    ckreq || return $?

    info=`print - "SELECT * from found where
macaddr=\"$obj[macaddr]\"
;" | $sql -batch $H/run/things.db`

    if [[ ${#info} = 0 ]]; then
        act "new: ${obj[macaddr]} ${obj[hostname]:-${obj[ip4]}} :: ${obj[os]}"
        # no records found
        nownow=`date -d @$now '+%Y-%m-%dT%H:%M'`
        cat <<EOF | $sql -batch $H/run/things.db
INSERT OR IGNORE
into found (macaddr,ip4,iface,state,last,age)
values("$obj[macaddr]","$obj[ip4]","$obj[iface]","$obj[state]",
"$nownow","$nownow");
EOF

        # TODO: send event to redis
        continue
    fi

    for i in "${(f)$(print $info | sql_idx_parse $R/db/thing.idx)}"; do
        strtok "$i" ' '
        _k="${tok[1]}"
        _v="${tok[2]}"
        [[ ${#tok} -gt 2 ]] && {
            for c in {3..${#tok}}; do
                _v+=" ${tok[$c]}"
            done
        }
        func "$_k = $_v"
        [[ "$obj[$_k]" = "" ]] || { # key is defined in object
            [[ "$obj[$_k]" = "$_v" ]] || { # values differ

                # TODO: send events to redis
                warning "${obj[hostname]} change $_k: $_v -> $obj[$_k]"

                # update in database
                cat <<EOF | $sql --echo -batch $H/run/things.db
UPDATE found SET $_k = "$obj[$_k]"
WHERE macaddr = "$obj[macaddr]";
EOF
            }
        }
    done


}
# finds out LAN neighbours, their mac and their state
# this establishes mac addresses as indexes
pendulum_ip_neigh() {
    fn pendulum_ip_neigh $*

    for o in "${(f)$(launch ip neigh)}"; do
        func "$o"

        # parse everything in a map
        obj=()

        # not interesting if no mac found (REVIEW)
        obj[macaddr]="${o[(w)5]}"
        [[ "$obj[mac]" = "FAILED" ]] && continue

        # get the ip address
        if [[ "$o{[(w)1]}" =~ "::" ]]; then
            obj[ip6]="${o[(w)1]}"
        else
            obj[ip4]="${o[(w)1]}"
        fi

        # we keep track only of ipv4 on the LAN for now
        [[ "${obj[ip4]}" = "" ]] && continue

        obj[iface]="${o[(w)3]}"

        obj[state]="${o[(w)6]}"

        _pendulum_resolve_hostname

        _pendulum_update_changes

    done
}

pendulum_arp_scan() {
    fn pendulum_arp_scan $*

    ###### Active ARP scan
    ## using netdiscover, retrieves OS from MAC fingerprints
    for _dev in ${(k)net_ip4_addr}; do
        _addr=${net_ip4_addr[$_dev]}
        _net=`pendulum_ip_to_network $_addr`
        func "arp scan $_net ($_dev)"
        for t in "${(f)$(launch netdiscover -i $_dev -r $_net -P -N)}"; do
            [[ "$t" = "" ]] && continue
            [[ "$t" =~ "^--" ]] && continue
            obj=()
            obj[macaddr]=${t[(w)2]}
            obj[ip4]=${t[(w)1]}
            obj[iface]=$_dev
            obj[last]=$nownow
            obj[os]="$(print - $t | awk '
{
  for(c=5;c<=NF;c++) {
    printf("%s_", $c)
  }
}')"
            _pendulum_resolve_hostname

            _pendulum_update_changes
        done
    done
}

[[ "$1" = "start" ]] && {
    notice "Starting pendulum on `date -d @$now`"
    # main
    while true; do
        pendulum_ip_neigh
        pendulum_arp_scan
        for i in {1..10}; do
            func "quit: $quit"
            [[ $quit = 1 ]] && {
                notice "Pendulum exiting."
                return 0
            }
            sleep 1
        done
    done
}
