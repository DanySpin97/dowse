#!/usr/bin/env zsh
#
# Copyright (C) 2016 Dyne.org Foundation
#
# Designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it
# and/or modify it under the terms of the GNU Public License
# as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later
# version.
#
# This source code is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  Please refer to the GNU Public License for more
# details.
#
# You should have received a copy of the GNU Public License
# along with this source code; if not, write to: Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
# 02139, USA.

# This standalone program runs every N seconds and gathers current
# information on network objects, updating it in redis

R=${0%/*}
[[ "$R" = "pendulum" ]] && R=/usr/local/dowse
[[ -r $R/zlibs ]] || {
    print "error: no zlibs found in $R"
    return 1 }

zkv=1
source $R/zlibs/zuper
source $R/zlibs/redis
source $R/zlibs/confstore
source $R/zlibs/sql

vars+=(R V now)
arrs+=(objidx)
maps+=(obj db execmap thing)
source $R/zlibs/zuper.init

func "load dataset indexes"
db=()
zkv.load $R/db/database.zkv

func "load paths and execmaps"
execmap=()
source $R/db/execmap.zkv

objidx=(ip hostname iface state os dhcp)
# age and last are apart
# mac is the index

settings=${settings:-/etc/dowse/settings}
conf-load

now=`date +'%s'`

resolve_obj_hostname() {
    fn resolve_obj_hostname $*

    hh="`host $obj[ip4] | awk '{print $NF}'`"
    hh[${#hh}]='\0'
    obj[hostname]=${hh%%.*}
    func "resolved: $obj[hostname]"
}

# finds out LAN neighbours, their mac and their state
# this establishes mac addresses as indexes
update-neigh() {
    fn update-neigh $*
    local hostname


    # for n in "${(f)$($R/bin/sup ${execmap[netdiscover]} -r $dowse_net -PN)}"; do
    #     act "netdiscover: $n"
    # done
    # execute `ip neigh` and parse the output line per line

    notice "Update neighbourhood on `date -d @$now`"
    for o in "${(f)$(${execmap[ip]} neigh)}"; do
        func "$o"

        # parse everything in a map
        obj=()

        # not interesting if no mac found (REVIEW)
        obj[macaddr]="${o[(w)5]}"
        [[ "$obj[mac]" = "FAILED" ]] && continue

        # get the ip4 address
        obj[ip4]="${o[(w)1]}"

        obj[iface]="${o[(w)3]}"

        obj[state]="${o[(w)6]}"

        resolve_obj_hostname

        saved=`print - "SELECT * from unknown where
macaddr=\"$obj[macaddr]\"
and ip4=\"$obj[ip4]\"
;" | $sql -batch $H/run/things.db`

        [[ ${#saved} = 0 ]] && {
            # no records found
            nownow=`date -d @$now '+%Y-%m-%dT%H-%M'`
            cat <<EOF | $sql -batch $H/run/things.db
INSERT OR IGNORE
into unknown (macaddr,ip4,iface,state,last,age)
values("$obj[macaddr]","$obj[ip4]","$obj[iface]","$obj[state]",
"$nownow","$nownow");
EOF
            continue
        }

        for i in "${(f)$(print $saved | sql_idx_parse $R/db/thing.idx)}"; do
           
            _k=${i[(w)1]}
            _v=${i[(w)2]}
            func "$_k = $_v"
            [[ "$obj[$_k]" = "" ]] || { # key is defined in object
                [[ "$obj[$_k]" = "$_v" ]] || { # values differ
                    # TODO: send events to redis
                    warning "changed $_k: $_v -> $obj[$_k]"
                }
            }
        done
        continue
        # update the last seen timestamp
        mac_ip_update_last $obj[mac] $obj[ip]

        # query our database from known and unknown hits using mac+ip as uniq
        known=`print - "SELECT * from known where macaddr=\"$obj[mac]\" and ip4=\"$obj[ip]\";" |
            $sql -batch $H/run/things.db`

        unknown=`print - "SELECT * from unknown where macaddr=\"$obj[mac]\" and ip4=\"$obj[ip]\";" |
            $sql -batch $H/run/things.db`


        if [[ ${#known} != 0 ]]; then # first quick check
            # TODO: do what needs to be done when mac address belongs to a known thing
            mac_ip_update_last $obj[mac] $obj[ip]

        elif [[ ${#unknown} != 0 ]]; then # unknown
            func "unknown"

            # update the last seen timestamp
            mac_ip_update_last $obj[mac] $obj[ip]

            # get and update the hostname
            mac_to_hostname_via_arp $obj[mac]

            # 
            # TODO: check changes
            # obj[state]="${o[(w)6]}"
            # obj[iface]="${o[(w)3]}"

        else # new entry to unknown
            # TODO: skip ipv6 for now
            [[ "$obj[ip]" =~ "::" ]] && continue

            obj[iface]="${o[(w)3]}"
            obj[mac]="${o[(w)5]}"
            obj[state]="${o[(w)6]}"

            # insert new entry, ignore if macaddr duplicate (REVIEW)
            cat <<EOF | $sql -batch $H/run/things.db
INSERT OR IGNORE
into unknown (macaddr,ip4,iface,state)
values("$obj[mac]","$obj[ip]","$obj[iface]","$obj[state]");
EOF

        fi
        # func "$obj"
        # stash-findings
    done

}

mac_ip_update_last() {
    fn mac_ip_update_last $*
    local _mac="$1"
    local _ip="$2"
    req=(_mac _ip)
    ckreq || return $?

    if nmap -sn -n -oG - $_ip >/dev/null; then

        cat <<EOF | $sql -batch $H/run/things.db
UPDATE known
SET last = "`date -d @$now +%D`"
WHERE macaddr = "$_mac";
EOF
        act "online $_mac $_ip"
    else
        act "offline $_mac $_ip"
    fi

}

# stashes all findings about current object lookup
stash-findings() {
    fn stash-findings
    news=0
    redis_cmd=''
    [[ "obj[mac]" = "" ]] && {
        warning "MAC identifier unknown, nothing to stash"
        return 1 }
    for i in $objidx; do
        [[ "$obj[$i]" = "" ]] || {
            redis_cmd+="SET obj_${obj[mac]}_$i \"$obj[$i]\"\n"
            news=1
        }
    done
    # deal with age and last seen
    [[ $news = 1 ]] && {
        redis_cmd+="SET obj_${obj[mac]}_last \"$now\"\n"
        print - "$redis_cmd" | redis dynamic 1>/dev/null
    }
}


# compates all old and new values, signals about changes and saves all
# in storage
store-findings() {
    fn store_findings

    for o_new in "${(f)$(print - 'keys obj_*_last' | redis dynamic)}"; do

        o_name=${o_new%_*}
        notice "$o_name"
        o_status=unchanged
        redis_cmd=''

        for i in $objidx; do
            fnew=$(print - "GET ${o_name}_$i" | redis dynamic)
            [[ "$fnew" = "" ]] && continue

            fold=$(print - "GET ${o_name}_$i" | redis storage)

            if [[ "$fold" = "" ]]; then
                act "$i new: $fnew"
                redis_cmd+="SET ${o_name}_$i \"$fnew\"\n"
                o_status=new

            elif [[ "$fnew" = "$fold" ]]; then
                func "$i unchanged"
            else
                act "$i changed: $fold -> $fnew"
                redis_cmd+="SET ${o_name}_$i  \"$fnew\"\n"
                o_status=changed
            fi

            print - "DEL ${o_name}_$i" | redis dynamic 1>/dev/null
        done

        case $o_status in
            new)
                redis_cmd+="SET ${o_name}_age \"$now\" \n"
                redis_cmd+="SET ${o_name}_last \"$now\" \n"
                ;;
            changed)
                redis_cmd+="SET ${o_name}_last \"$now\" \n"
                ;;
        esac
        print - "DEL ${o_name}_last" | redis dynamic 1>/dev/null

        print - $redis_cmd | redis storage 1>/dev/null

    done

}

list-objects() {
    fn list-objects $*
    _db=${1:-storage}

    for o in "${(f)$(print - "keys obj_*_last" | redis ${_db})}"; do
        [[ "$o" = "" ]] && continue
        o_name=${o%_*}
        redis_cmd=''
        notice "$o_name"
        for i in ${objidx}; do
            redis_cmd+="GET ${o_name}_$i\n"
        done

        c=1
        for l in "${(f)$(print - $redis_cmd | redis ${_db})}"; do
            act "${objidx[$c]}: $l"
            c=$(($c+1))
        done
    done
}

cmd=${1:-list}
case $cmd in
     update)
         update-neigh
         update-arp
         # list-objects dynamic
         store-findings
         ;;

     list)
         list-objects ${2:-storage}
         ;;
     "source") ;;
esac
